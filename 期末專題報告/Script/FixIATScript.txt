///////////////////////////////////////////////////////////////////////
//假设当前你已停在OEP附近,填完初始化地址即可开始跑脚本
//软件断点必须是占1个字节的，不能占2个字节以上
//initialization start
mov FixStartAddr,0x00007FF687EF1000            //初始化，前2个填text区段起始和末尾地址，后2个填wl壳区段起始和末尾地址    
mov FixEndAddr,0x00007FF687EF2000
mov wlStartAddr,0x0007FF687EF9000
mov wlEndAddr,0x00007FF688471000
//initialization end     
//setfreezestack 1                     //关闭GUI更新，防止dbg崩溃。
//LogDisable
//guiupdatedisable

alloc 0x20000                        //申请内存当做堆栈,以及给替换代码使用以防崩溃
mov cxpvalue,$RESULT+0x5000           
mov cbpvalue,$RESULT+0x10000         //固定cbp，csp
mov cspvalue,$RESULT+0x10000-0x100
BPHWC                                //删除所有断点
BC    
BPMC  
mov temp,FixStartAddr
mov NewIATAddr,wlEndAddr-0x2000      //往壳区段写入新IAT
mov SpecialAddr,wlEndAddr-0x3000     //往壳区段写入某些特殊的jmp[iat]
mov Call_Addr,0
mov Call_data,0
mov Call_jmpAddr,0

LOOP_Fix:
call FindCall(ff15)                        //寻找可能的call_section
cmp $RESULT,0                        //为0则修复完毕
je Loop_fix(2)
mov cax,cxpvalue                     //给替换代码使用以防崩溃(还解决了一些莫名其妙的异常崩溃问题，建议以后写脚本都留着)
mov cbx,cxpvalue
mov ccx,cxpvalue
mov cdx,cxpvalue
mov csi,cxpvalue
mov cdi,cxpvalue
mov cbp,cbpvalue                     //固定cbp，csp,以防某些情况下的堆栈崩溃
mov csp,cspvalue
call FixCallData                     //开始修复CALL_Section和IAT

jmp LOOP_Fix



FindCall(ff15):
find temp,FF15??????00,FixEndAddr-FixStartAddr
cmp $RESULT,0
je End1
mov Call_Addr,$RESULT
mov temp,Call_Addr+1
mov Call_data,4:[Call_Addr+2]
mov Call_jmpAddr,Call_Addr+Call_data+6
//mov Call_jmpAddr,Call_Addr+Call_data+5
mov Call_index,[Call_jmpAddr]
cmp Call_index,wlStartAddr
jle FindCall(ff15)
cmp Call_index,wlEndAddr
jge FindCall(ff15)
ret

FindCall(ff25):
find temp,FF25??????00,FixEndAddr-FixStartAddr
cmp $RESULT,0
je End1
mov Call_Addr,$RESULT
mov temp,Call_Addr+1
mov Call_data,4:[Call_Addr+2]
mov Call_jmpAddr,Call_Addr+Call_data+6
//mov Call_jmpAddr,Call_Addr+Call_data+5
mov Call_index,[Call_jmpAddr]
cmp Call_index,wlStartAddr
jle FindCall(ff25)
cmp Call_index,wlEndAddr
jge FindCall(ff25)
ret
End1:
ret
End2:
setfreezestack 0                     //解锁堆栈、GUI、日志记录
guiupdateenable 1
LogEnable
ret

FixCallData:
mov cip,Call_Addr                    //将CIP设置在call_section
sti                                  //第一处“奇妙”
mov [csp],0                          //这里必须要赋0，否则会影响后续call[iat]和jmp[iat]的识别
add csp,4
mov cip,Call_Addr
jmp Runinto

Runinto:
ticnd (mod.isexport(cax)==1||(CIP>wlEndAddr)||(CIP<wlStartAddr),0x100   //寻找xor eax,ebx/ecx/edx/.......
cmp CIP,wlStartAddr                  //判断找到的代码是不是壳区段中的。不是则说明它是替换代码
jle Special2
cmp CIP,wlEndAddr
jge Special2
//cmp 1:[CIP],0x31e8                     //判断找到的代码并跳到相应的脚本命令
//je xor_index
//cmp 1:[CIP],0x31d0                     //判断找到的代码并跳到相应的脚本命令
//je xor_index
//cmp 1:[CIP],0x31f0                     //判断找到的代码并跳到相应的脚本命令
//je xor_index
//cmp 1:[CIP],0x31f8                     //判断找到的代码并跳到相应的脚本命令
//je xor_index
//cmp 1:[CIP],0x31d8                     //判断找到的代码并跳到相应的脚本命令
//je xor_index
//cmp 1:[CIP],0x31c8                     //判断找到的代码并跳到相应的脚本命令
//je xor_index
//sti
jmp xor_index

xor_index:
sti                                  
mov APIAddr,cax                    //取得API地址
jmp Start_FixData                   //跳去修复数据


Special2:

BPHWC
ret

Start_FixData:
Call_IAT:
//mov [Call_Addr+2],APIAddr             //向IAT中写入API地址
cmp APIAddr,0
je Special2
mov [Call_jmpAddr],APIAddr
NewIATAddr+=4
ret

Loop_fix(2):
call FindCall(ff25)                        //寻找可能的Jmp_section
cmp $RESULT,0                        //为0则修复完毕
je End2
mov cax,cxpvalue                     //给替换代码使用以防崩溃(还解决了一些莫名其妙的异常崩溃问题，建议以后写脚本都留着)
mov cbx,cxpvalue
mov ccx,cxpvalue
mov cdx,cxpvalue
mov csi,cxpvalue
mov cdi,cxpvalue
mov cbp,cbpvalue                     //固定cbp，csp,以防某些情况下的堆栈崩溃
mov csp,cspvalue
call FixCallData                     //开始修复Jmp_Section和IAT
jmp Loop_fix(2)
