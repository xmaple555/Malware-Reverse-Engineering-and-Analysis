#include<Windows.h>
#include<stdio.h>
#include<iostream>

uintptr_t jmpBackAddy;
uintptr_t BaseAddr;
BYTE* ProcessMemory;
void __attribute__((naked)) hooked_func() {

    __asm {

        add rdx, rbp
        mov rdx, qword ptr ds : [rdx]
        mov r10, qword ptr ds : [r10]
        mov r9b, byte ptr ds : [r10]

        // new code
        
        push r10
        push rax
        sub r10, BaseAddr //r10 is a offset address
        
  
        mov rax,0
        add r10, ProcessMemory  // r10 = the dump memory + an offset address
        mov r9b, byte ptr ds : [r10] // rplace r9b with the dump memory byte
    
        pop rax
        pop r10
        
        //
        mov byte ptr ds : [rdx] , r9b
        mov rbx, 0
        mov r15, rbp
        jmp jmpBackAddy
    }
}



void Hook64(void* src, void* dst, int len)
{
    if (len < 14) return ;

    BYTE stub[14] = {
    0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,                // jmp qword ptr instruction
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 8 byte ptr to jmp destination
    };

    //void* pTrampoline = VirtualAlloc(0, len + sizeof(stub), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    DWORD oldProtect = 0;
    VirtualProtect(src, len, PAGE_EXECUTE_READWRITE, &oldProtect);

    uintptr_t jmpBackAddr = (uintptr_t)src + len;

    // copy trampoline jmpback addr to stub
    memcpy(stub + 6, &jmpBackAddr, 8);

    // copy dst to the stub, creating our jmp to our hook function
    memcpy(stub + 6, &dst, 8);
    // copy new stub to src
    memcpy(src, stub, sizeof(stub));

    // nop any stolen bytes in src
    for (int i = 14; i < len; i++)
    {
        *(BYTE*)((uintptr_t)src + i) = 0x90;
    }

    VirtualProtect(src, len, oldProtect, &oldProtect);
    
}

DWORD WINAPI HackThread(HMODULE hModule)
{
    
    
   
    AllocConsole();
    FILE* f;
    freopen_s(&f, "CONIN$", "r", stdin);
    freopen_s(&f, "CONOUT$", "w", stdout);
    freopen_s(&f, "CONOUT$", "w", stderr);
    
    std::cout << "The internal hack has been started.\n";

    
    BaseAddr = (uintptr_t)GetModuleHandle(0);
    ProcessMemory = (BYTE*)malloc(0x2000);
    ReadProcessMemory(GetCurrentProcess(), (void*)BaseAddr, ProcessMemory, 0x2000, NULL);


    Hook64((LPVOID)(BaseAddr + 0x1f6518), (LPVOID)hooked_func, 25);
    jmpBackAddy = BaseAddr + 0x1f6518 + 25;


    while (true) {

        if (GetAsyncKeyState(VK_END) & 1) {
            break;
        }
        Sleep(10);
    }
    
    

    
    fclose(stdin);
    fclose(stdout);
    fclose(stderr);
    FreeConsole();
    fclose(f);
    
    
    FreeLibraryAndExitThread(hModule, 0);
    
    
    
    return 0;

}


BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CloseHandle(CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)HackThread, hModule, 0, nullptr));
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}